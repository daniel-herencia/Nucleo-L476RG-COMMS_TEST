

#include "comms.h"


typedef enum
{
    LOWPOWER,
    RX,
    RX_TIMEOUT,
    RX_ERROR,
    TX,
    TX_TIMEOUT,
    START_CAD,
}States_t;

typedef enum
{
    CAD_FAIL,
    CAD_SUCCESS,
    PENDING,
}CadRx_t;



uint16_t BufferSize = BUFFER_SIZE;
uint8_t Buffer[BUFFER_SIZE];

States_t State = LOWPOWER;

int8_t RssiValue = 0;
int8_t SnrValue = 0;

#if(RX_FW == TX_FW)
    #error "Please define only one firmware."
#endif
CadRx_t CadRx = CAD_FAIL;
bool PacketReceived = false;
bool RxTimeoutTimerIrqFlag = false;
uint16_t channelActivityDetectedCnt = 0;
uint16_t RxCorrectCnt = 0;
uint16_t RxErrorCnt = 0;
uint16_t RxTimeoutCnt = 0;
uint16_t SymbTimeoutCnt = 0;
int16_t RssiMoy = 0;
int8_t SnrMoy = 0;
uint16_t txCounter = 0;
uint8_t aux[8];
uint64_t aux2;
uint8_t pack_num=0;
uint8_t photo_vect[]={0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
	  				0x00, 0x01, 0x00, 0x00, 0xFF, 0xE2, 0x02, 0x28, 0x49, 0x43, 0x43, 0x5F, 0x50, 0x52, 0x4F, 0x46,
	  				0x49, 0x4C, 0x45, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x30,
	  				0x00, 0x00, 0x6D, 0x6E, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x63, 0x73, 0x70, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01,
	  				0x00, 0x00, 0x00, 0x00, 0xD3, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00,
	  				0x00, 0xF0, 0x00, 0x00, 0x00, 0x74, 0x72, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00,
	  				0x00, 0x14, 0x67, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x78, 0x00, 0x00, 0x00, 0x14, 0x62, 0x58,
	  				0x59, 0x5A, 0x00, 0x00, 0x01, 0x8C, 0x00, 0x00, 0x00, 0x14, 0x72, 0x54, 0x52, 0x43, 0x00, 0x00,
	  				0x01, 0xA0, 0x00, 0x00, 0x00, 0x28, 0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xA0, 0x00, 0x00,
	  				0x00, 0x28, 0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xA0, 0x00, 0x00, 0x00, 0x28, 0x77, 0x74,
	  				0x70, 0x74, 0x00, 0x00, 0x01, 0xC8, 0x00, 0x00, 0x00, 0x14, 0x63, 0x70, 0x72, 0x74, 0x00, 0x00,
	  				0x01, 0xDC, 0x00, 0x00, 0x00, 0x3C, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E, 0x55, 0x53, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00,
	  				0x00, 0x1C, 0x00, 0x73, 0x00, 0x52, 0x00, 0x47, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x6F, 0xA2, 0x00, 0x00, 0x38, 0xF5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59,
	  				0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x99, 0x00, 0x00, 0xB7, 0x85, 0x00, 0x00,
	  				0x18, 0xDA, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xA0, 0x00, 0x00,
	  				0x0F, 0x84, 0x00, 0x00, 0xB6, 0xCF, 0x70, 0x61, 0x72, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
	  				0x00, 0x00, 0x00, 0x02, 0x66, 0x66, 0x00, 0x00, 0xF2, 0xA7, 0x00, 0x00, 0x0D, 0x59, 0x00, 0x00,
	  				0x13, 0xD0, 0x00, 0x00, 0x0A, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x59,
	  				0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	  				0xD3, 0x2D, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	  				0x00, 0x0C, 0x65, 0x6E, 0x55, 0x53, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x47,
	  				0x00, 0x6F, 0x00, 0x6F, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x20, 0x00, 0x49, 0x00, 0x6E,
	  				0x00, 0x63, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x36, 0xFF, 0xDB,
	  				0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,
	  				0x03, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x06, 0x06, 0x05, 0x06, 0x09, 0x08, 0x0A,
	  				0x0A, 0x09, 0x08, 0x09, 0x09, 0x0A, 0x0C, 0x0F, 0x0C, 0x0A, 0x0B, 0x0E, 0x0B, 0x09, 0x09, 0x0D,
	  				0x11, 0x0D, 0x0E, 0x0F, 0x10, 0x10, 0x11, 0x10, 0x0A, 0x0C, 0x12, 0x13, 0x12, 0x10, 0x13, 0x0F,
	  				0x10, 0x10, 0x10, 0xFF, 0xDB, 0x00, 0x43, 0x01, 0x03, 0x03, 0x03, 0x04, 0x03, 0x04, 0x08, 0x04,
	  				0x04, 0x08, 0x10, 0x0B, 0x09, 0x0B, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	  				0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	  				0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	  				0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x78, 0x00,
	  				0xA0, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xFF, 0xC4, 0x00, 0x1C, 0x00,
	  				0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x04, 0x00, 0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x0A, 0xFF, 0xC4, 0x00, 0x35, 0x10, 0x00, 0x02,
	  				0x01, 0x03, 0x02, 0x04, 0x04, 0x05, 0x03, 0x02, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
	  				0x05, 0x06, 0x07, 0x14, 0x01, 0x24, 0x08, 0x15, 0x34, 0x61, 0x11, 0x16, 0x44, 0x54, 0x02, 0x17,
	  				0x25, 0x31, 0x64, 0x21, 0x35, 0x51, 0x26, 0x41, 0x27, 0x33, 0x36, 0x45, 0x65, 0x81, 0x84, 0xF0,
	  				0xFF, 0xC4, 0x00, 0x19, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x05, 0x01, 0x06, 0xFF, 0xC4, 0x00, 0x2A, 0x11,
	  				0x01, 0x00, 0x02, 0x00, 0x05, 0x03, 0x03, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  				0x00, 0x03, 0x13, 0x01, 0x04, 0x11, 0x41, 0x61, 0x05, 0x14, 0x23, 0x02, 0x12, 0x51, 0x21, 0x31,
	  				0x24, 0x33, 0x52, 0x62, 0x91, 0xA1, 0xE1, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11,
	  				0x03, 0x11, 0x00, 0x3F, 0x00, 0xEA, 0x58, 0x84, 0x20, 0x08, 0xF5, 0x6B, 0x52, 0xA1, 0x48, 0x53,
	  				0xED, 0x4E, 0xB9, 0xF6, 0x4C, 0xE4, 0xAF, 0x10, 0x97, 0x53, 0xCF, 0x95, 0x43, 0x73, 0x8E, 0xBD,
	  				0xB4, 0xF4, 0x66, 0x95, 0xE3, 0x46, 0xFC, 0x66, 0x35, 0xE4, 0x78, 0x57, 0xB6, 0xA7, 0x3F, 0xEA,
	  				0xC7, 0x1E, 0x98, 0x6B, 0xF1, 0x0C, 0xEA, 0xBB, 0xA9, 0xAD, 0xD7, 0x41, 0x36, 0x35, 0x22, 0xB2,
	  				0xCE, 0x73, 0x86, 0x8F, 0x25, 0xB6, 0x71, 0x78, 0x23, 0xB2, 0x89, 0xA2, 0x08, 0xDE, 0xF2, 0x50,
	  				0xD1, 0x48, 0x8A, 0xE1, 0x8D, 0x2D, 0x92, 0xB9, 0x67, 0x08, 0xA3, 0x7B, 0xC1, 0x55, 0x72, 0x05,
	  				0xA8, 0x9E, 0x61, 0x2B, 0xF4, 0xC4, 0x7E, 0x24, 0x95, 0x09, 0x08, 0xAC, 0xB0, 0x22, 0x89, 0xF7,
	  				0x1D, 0x65, 0xBA, 0xB0, 0xB5, 0x13, 0xDA, 0x8A, 0xAB, 0x90, 0x6A, 0xE4, 0xFD, 0xC5, 0xE5, 0xBF,
	  				0xFE, 0xF1, 0x24, 0x02, 0x6C, 0x68, 0x47, 0xF9, 0x3F, 0x71, 0x61, 0x8E, 0xAD, 0x82, 0x0A, 0xAB,
	  				0x90, 0x6A, 0x04, 0x1D, 0x9B, 0x10, 0xD0, 0x10, 0x13, 0x0C, 0x76, 0x0A, 0xC3, 0x00, 0xFA, 0x36,
	  				0x28, 0x8E, 0x29, 0x2F, 0x54, 0x7D, 0xAA, 0xA3, 0x1A, 0xD3, 0x47, 0x7C, 0x1A, 0x6F, 0x4F, 0x0D,
	  				0x3B, 0x68, 0x5A, 0xB5, 0xB5, 0x5C, 0x85, 0x1D, 0x00, 0xCC, 0xDB, 0x9F, 0x6D, 0x3E, 0xC7, 0x28,
	  				0x6F, 0xCD, 0xC8, 0x7A, 0xF0, 0x56, 0x4D, 0xBC, 0xEB, 0xDB, 0x4F, 0x46, 0x12, 0xF9, 0x66, 0xAB,
	  				0xEC, 0xAD, 0x54, 0xD5, 0x95, 0x24, 0xE5, 0x61, 0x28, 0xDB, 0xCE, 0xFA, 0xD2, 0x2A, 0xDA, 0x6F,
	  				0x12, 0xA6, 0xDC, 0x46, 0x1C, 0x8A, 0xB7, 0x52, 0x66, 0x35, 0x82, 0x91, 0x5A, 0x41, 0x4A, 0x27,
	  				0xB5, 0x1A, 0xA5, 0xB6, 0x64, 0x83, 0xFD, 0xAF, 0x7A, 0x42, 0xA5, 0x9C, 0x00, 0x8F, 0xCB, 0x38,
	  				0x08, 0xA2, 0x79, 0x81, 0x7D, 0x61, 0x20, 0x89, 0x87, 0xEC, 0x00, 0x52, 0x90, 0xE1, 0x6A, 0x27,
	  				0x86, 0x3A, 0xE1, 0xE1, 0xAA, 0x35, 0x7A, 0x92, 0x40, 0x6A, 0x6D, 0x3E, 0xE1, 0x41, 0x6D, 0xA7,
	  				0xDC, 0x6A, 0xC3, 0x00, 0x29, 0x44, 0xFB, 0x82, 0xB6, 0x3A, 0x82, 0x00, 0x35, 0x02, 0x0E, 0xCD,
	  				0x82, 0x61, 0x80, 0x34, 0xB9, 0xD5, 0x1E, 0xA8, 0x9F, 0x71, 0xD7, 0x0C, 0x40, 0x02, 0x05, 0xA8,
	  				0x21, 0x12, 0x87, 0x4D, 0x78, 0xC6, 0xBE, 0xFA, 0x4B, 0xCA, 0x79, 0x1A, 0x15, 0xED, 0xA7, 0xAC,
	  				0x31, 0xFB, 0x6E, 0x76, 0x0B, 0x96, 0x98, 0xE7, 0x12, 0x8D, 0xBC, 0xEE, 0xED, 0xB7, 0x48, 0xA5,
	  				0x42, 0xE1, 0x7C, 0x31, 0x55, 0xBA, 0xB4, 0x56, 0xA1, 0x70, 0x12, 0x93, 0x87, 0xCC, 0x6B, 0x38,
	  				0x12, 0x59, 0xCD, 0xD1, 0x2B, 0x89, 0xFA, 0x3C, 0x0F, 0xE5, 0x9A, 0x18, 0x24, 0x09, 0x50, 0xB9,
	  				0x87, 0xB1, 0x21, 0x4D, 0xEF, 0x09, 0x07, 0x96, 0xE7, 0x26, 0x1A, 0xE8, 0x49, 0x04, 0x4D, 0x1F,
	  				0x87, 0xD6, 0x8A, 0xB7, 0x80, 0x8A, 0x53, 0xD4, 0xD9, 0x36, 0x51, 0x34, 0x61, 0xC2, 0x9B, 0x71,
	  				0x14, 0xD5, 0x22, 0xAD, 0xCC, 0x66, 0x34, 0x28, 0x0A, 0x96, 0x70, 0x8F, 0xC4, 0xF5, 0x63, 0xB6,
	  				0x1E, 0xD4, 0x4A, 0x27, 0xBA, 0x00, 0x75, 0x6D, 0x3D, 0xA9, 0x1F, 0x6D, 0x3E, 0xE4, 0xAF, 0x0F,
	  				0x6A, 0x34, 0xCB, 0x26, 0x48, 0x0D, 0x42, 0x10, 0x80, 0x04, 0x05, 0x1D, 0x41, 0x00, 0x05, 0x10,
	  				0x50, 0x29, 0x28, 0x26, 0xC4, 0xA2, 0x7D, 0xC2, 0x84, 0xA0, 0x04, 0xD9, 0x49, 0x8C, 0x36, 0x82,
	  				0xA5, 0xB7, 0x8A, 0x93, 0x69, 0x6E, 0x15, 0xEF, 0x14, 0x3C, 0x5E, 0x74, 0xD5, 0x2A, 0xE2, 0x85,
	  				0x53, 0xBE, 0x87, 0x6B, 0x05, 0xD2, 0xFB, 0xE3, 0xF9, 0x06, 0xAC, 0x3C, 0xC9, 0x42, 0x6B, 0x86,
	  				0xF2, 0x6A, 0xEC, 0x86, 0xAA, 0x79, 0x3F, 0xAA, 0x12, 0x09, 0x69, 0x8C, 0x3D, 0x8A, 0x43, 0x81,
	  				0x66, 0x61, 0x8D, 0x4D, 0xCC, 0x02, 0x36, 0xE7, 0x61, 0xAA, 0x59, 0xC4, 0x7F, 0x80, 0x01, 0x1B,
	  				0x73, 0xB0, 0xA2, 0x46, 0xA6, 0xDC, 0xCC, 0x25, 0x54, 0x9C, 0x3B, 0xD3, 0x0D, 0x28, 0x8A, 0x48,
	  				0xE5, 0xB6, 0xE8, 0x03, 0xB4, 0x4C, 0x3B, 0xD3, 0x0D, 0x28, 0x8C, 0x2A, 0x39, 0x6D, 0xBA, 0x69,
	  				0xFA, 0x7B, 0x83, 0xF8, 0x3A, 0x3E, 0xDC, 0xB7, 0x5C, 0x5C, 0xE7, 0xB1, 0x1B, 0xC3, 0x2E, 0x1E,
	  				0x1E, 0xEC, 0x9D, 0x2B, 0x64, 0xE9, 0x7F, 0x35, 0x56, 0x88, 0xE5, 0xD4, 0x0E, 0xFA, 0x42, 0xCA,
	  				0xAB, 0x39, 0x1C, 0xC4, 0x0F, 0x3C, 0xB8, 0x3B, 0x45, 0x3D, 0xA1, 0x9F, 0x34, 0xB6, 0xEC, 0x1C,
	  				0xBF, 0x6F, 0x05, 0x3C, 0xBC, 0x2E, 0x90, 0x8F, 0xB6, 0x5C, 0x17, 0xBA, 0xA4, 0xB7, 0x33, 0x15,
	  				0x47, 0xF8, 0x7C, 0x8E, 0x22, 0x85, 0x54, 0xD8, 0x5B, 0xC0, 0x47, 0xC4, 0x16, 0xD8, 0x20, 0x5B,
	  				0xC0, 0x21, 0x08, 0x42, 0x80, 0x46, 0xC1, 0x4F, 0x1C, 0xEA, 0x8F, 0x40, 0xDB, 0x78, 0x3A, 0x89,
	  				0x40, 0x40, 0xB5, 0x04, 0x5D, 0xC1, 0x4E, 0xFA, 0x4B, 0x28, 0x8C, 0xBA, 0xB8, 0x4F, 0x25, 0x95,
	  				0xA7, 0x72, 0x9D, 0xBA, 0xFC, 0x21, 0xD9, 0xDB, 0xAB, 0x07, 0xAA, 0x0F, 0xC2, 0x68, 0x93, 0x5A,
	  				0xFD, 0x9A, 0x57, 0xF4, 0xD4, 0xB0, 0xA7, 0xEB, 0xA8, 0x3A, 0x65, 0x46, 0x9D, 0x9A, 0x7D, 0x45,
	  				0x3C, 0x3F, 0x9D, 0x4C, 0xD5, 0x78, 0xB8, 0xFB, 0xA5, 0x69, 0xA5, 0x5A, 0x46, 0x8A, 0x4B, 0x2D,
	  				0xAF, 0x75, 0xFD, 0x87, 0x43, 0x9D, 0x8A, 0x63, 0xAA, 0xCC, 0x7C, 0xB1, 0xAD, 0xF8, 0xB1, 0x1F,
	  				0x22, 0x2B, 0x1E, 0x46, 0x94, 0xE7, 0x36, 0x2A, 0xA6, 0xD3, 0xC3, 0x68, 0x2E, 0xE6, 0xDE, 0x09,
	  				0xCA, 0xC2, 0x79, 0xB9, 0xC9, 0xAE, 0xAD, 0xD2, 0x12, 0xDD, 0x78, 0xF7, 0xAD, 0x2B, 0xC9, 0xB9,
	  				0x34, 0x55, 0x6E, 0x76, 0x6D, 0xCE, 0xC0, 0x8D, 0xA7, 0xDC, 0x2D, 0x4D, 0xE2, 0xB9, 0xC9, 0x02,
	  				0x61, 0xE6, 0x74, 0x45, 0x65, 0x14, 0x4D, 0x36, 0xF4, 0xC4, 0xA2, 0x88, 0xC2, 0xEE, 0xDB, 0x74,
	  				0xE8, 0x07, 0x0C, 0xBC, 0x3D, 0xC1, 0xDB, 0x78, 0x15, 0x2B, 0x8A, 0xD3, 0xFD, 0x41, 0xE8, 0xD4,
	  				0x22, 0xBC, 0x2D, 0x59, 0xF8, 0x3B, 0x56, 0xAA, 0x97, 0x1A, 0xE0, 0xA3, 0x97, 0x2A, 0xEF, 0x46,
	  				0xA1, 0xAA, 0xAA, 0xC9, 0x8A, 0x56, 0x1E, 0x2F, 0xE6, 0x35, 0x68, 0x8E, 0x22, 0x89, 0x6F, 0x53,
	  				0x50, 0xCF, 0x9A, 0x5B, 0x76, 0x36, 0xAE, 0x42, 0x37, 0x31, 0x07, 0x47, 0xC5, 0xB7, 0x75, 0x2E,
	  				0x0B, 0xC9, 0xEC, 0xBA, 0x35, 0x0C, 0x15, 0xC4, 0x27, 0x10, 0x93, 0x97, 0x52, 0x7B, 0x65, 0x98,
	  				0xA4, 0x52, 0x43, 0x55, 0xEE, 0xBF, 0x13, 0x97, 0x52, 0x79, 0xB7, 0xB7, 0x8A, 0x44, 0xFA, 0x35,
	  				0x07, 0x5B, 0x0D, 0x67, 0xE9, 0x5B, 0xA8, 0xAB, 0x79, 0xAF, 0x7D, 0x57, 0xDA, 0x0A, 0x76, 0xAE,
	  				0x54, 0xFA, 0x86, 0x80, 0xB7, 0xBC, 0x3D, 0xBD, 0x58, 0x5A, 0xF9, 0x59, 0xC7, 0x51, 0xC4, 0xFC,
	  				0xB0, 0xB5, 0x38, 0x33, 0x9C, 0x4E, 0xA8, 0xDE, 0xBD, 0x89, 0x4F, 0xA5, 0xEA, 0xCB, 0x56, 0xA1,
	  				0xE2, 0x72, 0xDC, 0xD3, 0x76, 0xE5, 0xBB, 0x3A, 0x96, 0xEF, 0x09, 0x3C, 0x2C, 0xB2, 0x79, 0x65,
	  				0xB7, 0x6D, 0x0D, 0xF6, 0xC9, 0xFA, 0x58, 0x7D, 0x4A, 0x6F, 0x9C, 0x4F, 0x60, 0xA4, 0x2A, 0xB2,
	  				0x83, 0x9C, 0xA6, 0xFA, 0xD2, 0xC0, 0xB6, 0x49, 0xE6, 0x4A, 0x67, 0x16, 0x5C, 0xB4, 0x3F, 0x38,
	  				0xEB, 0x4B, 0x21, 0x8E, 0xDD, 0xF4, 0x64, 0xCD, 0x9B, 0xAB, 0x66, 0x54, 0x04, 0x2F, 0x6A, 0xB2,
	  				0xCF, 0xE6, 0x6F, 0xA1, 0x4A, 0x7E, 0x5A, 0x1D, 0xE8, 0x76, 0xB0, 0x5D, 0x16, 0x6C, 0x32, 0xDD,
	  				0xB6, 0x88, 0xF8, 0x9B, 0x0A, 0x6C, 0x14, 0x84, 0xE2, 0x0A, 0x50, 0x14, 0x28, 0x03, 0x4B, 0x5C,
	  				0x2B, 0xC1, 0x55, 0x57, 0x8D, 0x6F, 0x5E, 0x29, 0xF6, 0xD3, 0x79, 0xC2, 0x54, 0xA4, 0x3B, 0xCE,
	  				0x16, 0x05, 0x27, 0x41, 0xE6, 0x35, 0xBD, 0x15, 0xDC, 0x47, 0xF2, 0xDC, 0x86, 0x1B, 0xB7, 0xD1,
	  				0x5F, 0xD3, 0xD6, 0x7F, 0x9C, 0x2B, 0xD0, 0x95, 0xAD, 0xE3, 0xA3, 0xD1, 0xA6, 0xDA, 0x37, 0xAC,
	  				0x4D, 0x1E, 0x8A, 0x71, 0x7D, 0x09, 0x8F, 0xF8, 0xB0, 0x4F, 0x0E, 0x79, 0x44, 0x45, 0x41, 0x9D,
	  				0x92, 0x5C, 0xDF, 0xC1, 0xB9, 0xCC, 0x9C, 0x7D, 0xA2, 0x94, 0xA4, 0xE6, 0x30, 0xDA, 0xC1, 0x2C,
	  				0x0A, 0x7A, 0x61, 0x18, 0x79, 0xE8, 0x99, 0xCE, 0xAD, 0x44, 0x9C, 0x2B, 0x5C, 0x31, 0xD6, 0x26,
	  				0x63, 0x0F, 0x62, 0xE9, 0xE9, 0xEA, 0xE5, 0xE7, 0x9D, 0x35, 0xA4, 0xEB, 0x04, 0x5C, 0x81, 0x52,
	  				0xEA, 0x54, 0xFF, 0x00, 0xB5, 0x24, 0x9E, 0xCD, 0x43, 0x2F, 0xF1, 0x09, 0xC4, 0xE4, 0xE5, 0xD4,
	  				0x94, 0x6D, 0x14, 0x9E, 0xFE, 0x9F, 0xF6, 0x85, 0x3F, 0xF3, 0x22, 0xAA, 0xF2, 0xBF, 0x95, 0x79,
	  				0xE7, 0xD2, 0xBD, 0xA1, 0x20, 0xB4, 0xF6, 0xAE, 0x72, 0xE4, 0x35, 0xFF, 0x00, 0x14, 0x97, 0x58,
	  				0xD9, 0x01, 0xD2, 0xC9, 0x6E, 0xC8, 0xAE, 0x61, 0xAA, 0xAD, 0x3D, 0x37, 0xF2, 0x4E, 0x83, 0xF9,
	  				0xA9, 0x9D, 0xF5, 0x5F, 0x68, 0x0B, 0x6F, 0x6C, 0x9D, 0x2B, 0x0F, 0x3C, 0xDD, 0x71, 0x53, 0xA3,
	  				0xFD, 0x3F, 0x0C, 0x55, 0x37, 0xE6, 0xF0, 0x79, 0xF2, 0x7B, 0x06, 0x98, 0xCC, 0x4E, 0x9F, 0x4B,
	  				0xA3, 0x03, 0x61, 0xF1, 0x2F, 0x68, 0x9E, 0x39, 0x39, 0xC5, 0x2F, 0x2B, 0x07, 0x5A, 0x41, 0xF5,
	  				0xBE, 0xD0, 0xCF, 0xF1, 0x34, 0xDB, 0xD5, 0x23, 0x5B, 0x24, 0x46, 0x9B, 0x7B, 0x41, 0xBD, 0x52,
	  				0x4A, 0x7E, 0x21, 0xAD, 0xA8, 0x8A, 0x6D, 0x14, 0xF1, 0x11, 0x49, 0x12, 0x29, 0xBC, 0x3C, 0xB9,
	  				0x17, 0x96, 0x5A, 0xBE, 0xC8, 0xA5, 0x27, 0x6D, 0xFC, 0xB7, 0x03, 0xF9, 0x64, 0x52, 0xA1, 0xAF,
	  				0x11, 0xA6, 0xDA, 0xC1, 0x2F, 0x6A, 0xDE, 0x9B, 0x9C, 0x4E, 0x2D, 0xBC, 0x23, 0x2F, 0xCB, 0x51,
	  				0xF3, 0x8E, 0x35, 0x9D, 0x83, 0xBB, 0x1D, 0x0C, 0xD6, 0xEC, 0xEF, 0x6B, 0xDA, 0xEF, 0xA8, 0xA8,
	  				0x9B, 0x90, 0xF4, 0xC4, 0xA6, 0x0E, 0x0E, 0xD0, 0xB2, 0xE5, 0xAD, 0x5A, 0x35, 0x24, 0x5E, 0xF5,
	  				0x12, 0xB4, 0xB6, 0x54, 0x7B, 0xCE, 0x55, 0x0A, 0x1A, 0xAD, 0xB4, 0xF9, 0x3C, 0x59, 0x65, 0xBC,
	  				0x25, 0xEC, 0xE4, 0x62, 0xAA, 0xDE, 0xD5, 0xBD, 0x4D, 0xB5, 0xEE, 0xD5, 0x2B, 0xFE, 0x4F, 0xDC,
	  				0xD9, 0x52, 0xD0, 0xFC, 0xE1, 0xA6, 0xF3, 0x4A, 0xAA, 0xAC, 0xB6, 0xF9, 0x8D, 0x67, 0x42, 0xA2,
	  				0xE6, 0x21, 0x98, 0xA9, 0x9F, 0xF0, 0xF7, 0x40, 0x8D, 0x96, 0x04, 0xB5, 0x37, 0x86, 0x35, 0x29,
	  				0x47, 0xBD, 0x30, 0xD6, 0x0A, 0x48, 0x82, 0x46, 0x8B, 0xA7, 0xA8, 0xF2, 0xE0, 0xA4, 0xE8, 0xFC,
	  				0x35, 0x47, 0x5A, 0x22, 0x8F, 0xCC, 0x54, 0xB5, 0x62, 0x69, 0xBC, 0x35, 0x8C, 0x49, 0xA5, 0xAB,
	  				0x6D, 0x5E, 0xE3, 0x28, 0x8A, 0xA9, 0x4D, 0xED, 0x7A, 0x13, 0x1A, 0x71, 0x61, 0x0F, 0x99, 0x54,
	  				0x1D, 0x00, 0x96, 0x4F, 0xD0, 0xC2, 0xF5, 0x66, 0x5F, 0xE2, 0x96, 0xDB, 0xF2, 0x75, 0x54, 0x79,
	  				0xDE, 0xAD, 0xD2, 0xBE, 0x9B, 0x15, 0xB2, 0xDB, 0xA9, 0x3D, 0x4A, 0x78, 0xE2, 0x86, 0xAD, 0x75,
	  				0x62, 0xA5, 0x28, 0xF1, 0x4B, 0x51, 0xC8, 0x96, 0xAF, 0x27, 0xEE, 0x09, 0xC9, 0xFB, 0x9E, 0xA1,
	  				0xE3, 0x71, 0x53, 0xEA, 0x26, 0xF2, 0x6D, 0x1D, 0x00, 0xB0, 0xC9, 0xC1, 0xD6, 0x14, 0x6C, 0x55,
	  				0x2B, 0x45, 0xED, 0x3D, 0xE1, 0x95, 0x5B, 0xA3, 0xF3, 0x02, 0xA9, 0x3A, 0xC2, 0xB8, 0xB5, 0x6D,
	  				0x67, 0x42, 0x84, 0xDE, 0x51, 0x0E, 0x15, 0x35, 0x05, 0xD8, 0xB9, 0x0F, 0x51, 0xED, 0x4A, 0xDB,
	  				0x94, 0xA0, 0xF2, 0xD4, 0xC3, 0x33, 0x55, 0x27, 0x61, 0xEA, 0xAA, 0x92, 0x53, 0xF1, 0x04, 0xDD,
	  				0xD4, 0x9C, 0xAC, 0x25, 0x33, 0xA6, 0x9E, 0xDD, 0x97, 0x05, 0xBD, 0xAF, 0x3D, 0x0B, 0xAF, 0x0A,
	  				0x86, 0x2A, 0xB7, 0x73, 0x38, 0x95, 0xD3, 0xD6, 0xAF, 0xCB, 0x71, 0x78, 0x29, 0x22, 0x58, 0x14,
	  				0x45, 0x36, 0xF7, 0x34, 0x50, 0x51, 0x35, 0x21, 0x65, 0x5B, 0xD7, 0x11, 0x73, 0xAD, 0x39, 0x9C,
	  				0x8B, 0x7D, 0x47, 0x4E, 0xF1, 0x2B, 0x5B, 0xC7, 0x5E, 0x79, 0x3D, 0xA5, 0x20, 0xF0, 0x7A, 0xD2,
	  				0x28, 0xA4, 0x3A, 0x3C, 0xAF, 0x65, 0xBB, 0x69, 0xD2, 0xE0, 0xAD, 0xED, 0x5B, 0xD3, 0x0D, 0x67,
	  				0x60, 0xE5, 0x82, 0xD2, 0x7C, 0x3D, 0xBD, 0x30, 0xAE, 0x77, 0x48, 0x2B, 0x05, 0x8C, 0xD3, 0x12,
	  				0x9B, 0xD4, 0x1D, 0x51, 0x9C, 0xE9, 0x6A, 0xB6, 0xE7, 0x38, 0xDF, 0x17, 0xB2, 0x9C, 0x3D, 0xD2,
	  				0xA9, 0xEF, 0xA6, 0xB7, 0x6D, 0x84, 0xD3, 0xF6, 0x59, 0x04, 0xDB, 0xE7, 0x55, 0x2E, 0xBA, 0x2B,
	  				0x16, 0x9E, 0x9E, 0x3A, 0x28, 0x46, 0x6D, 0xF1, 0xFC, 0xAA, 0xBA, 0x22, 0xCF, 0xCE, 0x57, 0x8D,
	  				0x67, 0x60, 0xE2, 0x45, 0x17, 0x4D, 0xD8, 0xD2, 0x97, 0xB7, 0x16, 0xED, 0x95, 0x11, 0x86, 0x53,
	  				0x46, 0x5C, 0xD3, 0x09, 0x3F, 0x87, 0xC3, 0xEE, 0x79, 0xF0, 0xDD, 0x4F, 0x8A, 0x5E, 0x4B, 0x4A,
	  				0x5E, 0xDA, 0xC2, 0x68, 0xDA, 0xDE, 0x1F, 0xAB, 0x7A, 0x7D, 0xB4, 0x1D, 0x94, 0xB3, 0xE8, 0xCB,
	  				0xB7, 0xA4, 0xD5, 0x66, 0xE7, 0x36, 0x6B, 0xC3, 0xFE, 0x87, 0x61, 0x17, 0xBF, 0xF2, 0xB1, 0xD5,
	  				0x2D, 0x9C, 0x31, 0x0A, 0x9C, 0x3D, 0xD7, 0x15, 0xE7, 0xEC, 0xB0, 0x7F, 0xFA, 0xCB, 0x55, 0x3E,
	  				0x10, 0x34, 0xB7, 0x10, 0x39, 0xDA, 0x6B, 0xA3, 0x8D, 0xE8, 0x6C, 0x94, 0xD2, 0x4D, 0x25, 0x30,
	  				0x93, 0x4B, 0x45, 0x56, 0xED, 0xA7, 0x80, 0x5B, 0x7F, 0xE4, 0x1C, 0xCD, 0xE4, 0x3C, 0x56, 0x7B,
	  				0xBF, 0xAF, 0xF5, 0x5C, 0x32, 0xD5, 0xB3, 0x1B, 0x5B, 0xD7, 0x11, 0xE5, 0x79, 0xCE, 0x96, 0x54,
	  				0x4C, 0xBA, 0x13, 0x0D, 0xA9, 0x09, 0x9B, 0x89, 0xAB, 0x82, 0x11, 0x89, 0x83, 0x7F, 0x35, 0x99,
	  				0x93, 0x2B, 0x87, 0x8B, 0x1D, 0x16, 0xA4, 0x35, 0x25, 0x1F, 0x15, 0xA7, 0x8F, 0xC1, 0xAF, 0x8B,
	  				0x3F, 0xC9, 0x98, 0x78, 0x9A, 0xB6, 0xF5, 0xC5, 0x79, 0x53, 0xEC, 0x91, 0xDA, 0x26, 0x21, 0x1B,
	  				0x19, 0x4C, 0x34, 0xC7, 0x47, 0x9C, 0x87, 0xF1, 0x58, 0xE3, 0x6F, 0xD5, 0x9F, 0xDB, 0xB2, 0x75,
	  				0xC2, 0x6A, 0xFE, 0xC6, 0xE1, 0x14, 0x6E, 0x83, 0xAA, 0x93, 0x6B, 0xF6, 0x37, 0x04, 0x23, 0x55,
	  				0x18, 0x5F, 0x2D, 0xCE, 0x27, 0xD6, 0xA2, 0x2C, 0x3C, 0xCE, 0xB5, 0x11, 0x08, 0x1C, 0x45, 0x25,
	  				0xAD, 0xBF, 0xAE, 0x48, 0x69, 0x89, 0xE7, 0x90, 0xE2, 0x11, 0xDC, 0x02, 0xD6, 0xA2, 0x2E, 0x47,
	  				0x27, 0x69, 0x4C, 0xDE, 0x94, 0xD1, 0x74, 0x9D, 0x79, 0x07, 0x52, 0x7A, 0xE1, 0x08, 0x8B, 0x38,
	  				0xD7, 0xE9, 0x0B, 0x2F, 0xCF, 0x9E, 0x4F, 0xC4, 0xDF, 0x65, 0x96, 0x4A, 0x8F, 0x56, 0xCE, 0x46,
	  				0xE5, 0xA5, 0x0B, 0xA2, 0x9F, 0x17, 0xDF, 0xC1, 0xBD, 0x7F, 0x51, 0x08, 0x93, 0xD2, 0x46, 0x6E,
	  				0x7F, 0xDB, 0x87, 0xF0, 0x76, 0x57, 0x5D, 0x68, 0xF8, 0xC6, 0xA6, 0xEA, 0x79, 0xBF, 0x1D, 0x3F,
	  				0x93, 0x3F, 0xCA, 0xD7, 0x75, 0xC5, 0xEB, 0x9D, 0xE4, 0x70, 0xA9, 0x62, 0x45, 0x7B, 0x5D, 0x7F,
	  				0xB8, 0x84, 0x58, 0x83, 0x06, 0x88, 0xB7, 0xD4, 0x3C, 0x7D, 0x1D, 0x17, 0xA2, 0x29, 0xEB, 0xA6,
	  				0x4F, 0xC5, 0xE1, 0x95, 0xAF, 0x8F, 0xDF, 0x52, 0x5C, 0x21, 0x15, 0xE5, 0x15, 0x3C, 0xF0, 0xF0,
	  				0x18, 0x2A, 0x19, 0x8C, 0x35, 0x44, 0x23, 0x2F, 0xAB, 0xE6, 0x24, 0xF4, 0xFD, 0x30, 0xC4, 0x3F,
	  				0xFF, 0xD9};

uint8_t tx_non_stop = 0; //1 => yes ; 0 => not
uint8_t testRX = false;


/* FLAGS */
uint8_t error_telecommand = false;
uint8_t tle_telecommand = false;
uint8_t telecommand_rx = false;
uint8_t tx_flag = false;
uint8_t contact_GS = false; //To avoid TX beacon
uint8_t request_execution = 0;
uint8_t rx_attemps_counter=0;




/* COUNTERS */
uint8_t rtx_confirms = 0;	//Maximum 3 retransmissions of execution request

// VARIABLES FROM OLD CODE
uint8_t calib_packets = 0;			//Counter of the calibration packets received
uint8_t tle_packets = 0;			//Counter of the tle packets received
uint8_t telemetry_packets = 0;		//Counter of telemetry packets sent
uint8_t count_packet[] = {0};		//To count how many packets have been sent (maximum WINDOW_SIZE)
uint8_t count_window[] = {0};		//To count the window number
uint8_t count_rtx[] = {0};			//To count the number of retransmitted packets
uint8_t i=0;						//variable for loops
uint8_t j=0;						//variable for loops
uint8_t k=0;						//variable for loops
uint64_t ack;						//Information rx in the ACK (0 => ack, 1 => nack)
uint8_t nack_number;				//Number of the current packet to retransmit
bool nack;							//True when retransmission necessary
bool full_window;					//Stop & wait => to know when we reach the limit packet of the window
bool statemach = true;				//If true, comms workflow follows the state machine. This value should be controlled by OBC
									//Put true before activating the statemachine thread. Put false before ending comms thread
bool send_data = false;				//If true, the state machine send packets every airtime
bool send_telemetry = false;		//If true, we have to send telemetry packets instead of payload data
uint8_t num_telemetry = 0;			//Total of telemetry packets that have to be sent (computed when telecomand send telemetry received)
bool contingency = false;			//True if we are in contingency state => only receive

/**
 * Main application entry point.
 */
void StateMachine( void )
{
    uint16_t PacketCnt = 0, i=0;
    float Per = 0.0;
    uint16_t bucleCounter = 0;
    uint16_t defaultCounter = 0;
    uint16_t rxCounter = 0;
    uint16_t cadCounter = 0;
    uint16_t failCADCounter = 0;
    uint16_t test_counter = 0;
    uint16_t tx_count = 0;

    uint8_t compare_arrays = 0;

    States_t copy_state = State;	//ERASE AFTER FINISH TESTING
    uint8_t reception_ack_mode = false;


    // MOVE THIS TWO TO GLOBAL VARIABLES
    uint8_t paquet_to_send;
    uint8_t last_telecommand[BUFFER_SIZE];	//Last telecommand RX
    uint8_t request_counter = 0;

    // Target board initialization
    BoardInitMcu( );
    BoardInitPeriph( );

    // Radio initialization
    RadioEvents.TxDone = OnTxDone;
    RadioEvents.RxDone = OnRxDone;
    RadioEvents.TxTimeout = OnTxTimeout;
    RadioEvents.RxTimeout = OnRxTimeout;
    RadioEvents.RxError = OnRxError;
    RadioEvents.CadDone = OnCadDone;

    //Timer used to restart the CAD
    TimerInit( &CADTimeoutTimer, CADTimeoutTimeoutIrq );
    TimerSetValue( &CADTimeoutTimer, CAD_TIMER_TIMEOUT );

    //App timmer used to check the RX's end
    TimerInit( &RxAppTimeoutTimer, RxTimeoutTimerIrq );
    TimerSetValue( &RxAppTimeoutTimer, RX_TIMER_TIMEOUT );

    Radio.Init( &RadioEvents );
    Radio.SetChannel( RF_FREQUENCY );

//#if defined( USE_MODEM_LORA )

    Radio.SetTxConfig( MODEM_LORA, TX_OUTPUT_POWER, 0, LORA_BANDWIDTH,
                                   LORA_SPREADING_FACTOR, LORA_CODINGRATE,
                                   LORA_PREAMBLE_LENGTH, LORA_FIX_LENGTH_PAYLOAD_ON,
                                   true, 0, 0, LORA_IQ_INVERSION_ON, 3000 );

    Radio.SetRxConfig( MODEM_LORA, LORA_BANDWIDTH, LORA_SPREADING_FACTOR,
                                   LORA_CODINGRATE, 0, LORA_PREAMBLE_LENGTH,
                                   LORA_SYMBOL_TIMEOUT, LORA_FIX_LENGTH_PAYLOAD_ON,
                                   0, true, 0, 0, LORA_IQ_INVERSION_ON, true );


    SX126xConfigureCad( CAD_SYMBOL_NUM,CAD_DET_PEAK,CAD_DET_MIN,CAD_TIMEOUT_MS);            // Configure the CAD
    Radio.StartCad( );          // do the config and lunch first CAD

    State = RX;

    while(  i < NB_TRY )
    {
		//DelayMs( 300 );
    	bucleCounter = bucleCounter + 1;

    	if (tx_non_stop == 1){
    		//DelayMs( 300 );
    	}else{
    		DelayMs( 1 );
    	}
    	//NO SE RX EL PRIMER PAQUETE EN EL CUBECELL. El ultimo no se recive en el stm32
        Radio.IrqProcess( );
        copy_state = State;
        switch( State )
        {
            case RX_TIMEOUT:
            {
                RxTimeoutCnt++;
                //State = START_CAD;
                //Radio.Rx( RX_TIMEOUT_VALUE );	//Basic RX code
				//DelayMs(1);	//Basic RX code
                Radio.Standby;
				State = LOWPOWER;
                break;
            }
            case RX_ERROR:
            {
                RxErrorCnt++;
                PacketReceived = false;
                //State = START_CAD;
                //Radio.Rx( RX_TIMEOUT_VALUE );	//Basic RX code
				//DelayMs(1);	//Basic RX code
                Radio.Standby;
				State = LOWPOWER;
            break;
            }
            case RX:
            {
                if( PacketReceived == true )
                {

					if (pin_correct(Buffer[0], Buffer[1])){
						State = LOWPOWER;
						if (Buffer[2] == TLE){
							if (!tle_telecommand){	//First TLE packet
								tle_telecommand = true;
								State = RX;
								telecommand_rx = true;
							}
							else{	//Is the last TLE packet (there are 2)
								tle_telecommand = false;
								State = LOWPOWER;	//Line unnecessary
								telecommand_rx = false;
							}
							process_telecommand(Buffer[2], Buffer[3]);	//Saves the TLE
						}
						else if (telecommand_rx){	//Second telecommand RX consecutively
							if (Buffer[2] == last_telecommand[2]){	//Second telecommand received equal to the first CHANGE THIS TO CHECK THE WHOLE TELECOMMAND. USE VARIABLE compare_arrays
								//Buffer[2] == (SEND_DATA || SEND_TELEMETRY || ACK_DATA || SEND_CALIBRATION || SEND_CONFIG)
								if (Buffer[2] == SEND_DATA || Buffer[2] == SEND_TELEMETRY || Buffer[2] == ACK_DATA || Buffer[2] == SEND_CALIBRATION || Buffer[2] == SEND_CONFIG){
									telecommand_rx = false;
									process_telecommand(Buffer[2], Buffer[3]);
								}
								else {
									request_execution = true;
									State = TX;
								}
							}
							else if(Buffer[2] == ACK){	//Order execution ACK
								request_execution = false;
								reception_ack_mode = false;
								telecommand_rx = false;
								process_telecommand(last_telecommand[2], last_telecommand[3]);
								State = RX;
							}
							else{	//Second telecommand received different from the first
							    State = TX;
							    telecommand_rx = false;
							    error_telecommand = true;
							    DelayMs(10);
							}
						}
						else{	//First telecommand RX
							memcpy( last_telecommand, Buffer, BufferSize );
							telecommand_rx = true;
							State = RX;
						}
					} else{	//Pin not correct. If pin not correct it is assumed that the packet comes from another source. The protocol continues ignoring it
					    State = TX;
					    error_telecommand = true;
					    DelayMs(10);
					}
                    PacketReceived = false;     // Reset flag
                }
                else	//If packet not received, restart reception process
                {
                    if (CadRx == CAD_SUCCESS)
                    {
                        channelActivityDetectedCnt++;   // Update counter
                        RxTimeoutTimerIrqFlag = false;
                        TimerReset(&RxAppTimeoutTimer);	// Start the Rx's's Timer
                        //Radio.Rx( RX_TIMEOUT_VALUE );   // CAD is detected, Start RX
                    }
                    else
                    {
                        TimerStart(&CADTimeoutTimer);   // Start the CAD's Timer
                    }
                    Radio.Rx( RX_TIMEOUT_VALUE );	//Basic RX code
                    DelayMs(1);	//Basic RX code
                    State = LOWPOWER;

                	if (reception_ack_mode){
                		reception_ack_mode = false;
                		DelayMs( 500 );
                	}
                }
                break;
            }
            case TX:
            {
            	/* TO TEST TELECOMMANDS */
            	State = LOWPOWER;
            	            	if (error_telecommand){	//Send error message
            	            		uint8_t paquet_to_send[] = {ERROR,ERROR,ERROR};
            	            		Radio.Send(paquet_to_send,sizeof(paquet_to_send));
            	            		DelayMs(100);
            	            		Radio.Send(paquet_to_send,sizeof(paquet_to_send));	//DISCOMMENT THIS LINE
            	                    error_telecommand = false;
            	            	} else if (request_execution){	//Send request for execute telecommand order
            	            		//paquet_to_send = last_telecommand[2];
            	            		//Radio.Send(paquet_to_send,1);
            	            		DelayMs(100);
            	            		Radio.Send(last_telecommand,sizeof(last_telecommand));	//TEST ONLY SENDING ONE REQUEST (NORMALLY PACKETS ARE TX IN PAIRS
            	            		DelayMs(100);
            	            		Radio.Send(last_telecommand,sizeof(last_telecommand));	//Better here or iterate another time and return to TX?
            	            		request_counter++;
            	            		reception_ack_mode = true;
            	            		State = RX;
            	            		rx_attemps_counter = 0;
            	            		//TimerStart(&CADTimeoutTimer);
            	            		//Radio.Rx( RX_TIMEOUT_VALUE );
            	            		//PacketReceived = false;
            	            	} else if (tx_flag || tx_non_stop){	//Send data
            	                    txfunction();
            	                    DelayMs( 300 );
            	                    Radio.Send( Buffer, BUFFER_SIZE );
            	            	}
            	//Radio.Send(SEND_DATA, sizeof(SEND_DATA));

            	/* TO TEST PROTOCOL AND SWITCHING BETWEEN STATES
                // Send the next frame
                txfunction();
                //Send Frame
                DelayMs( 1 );
                Radio.Send( Buffer, BUFFER_SIZE );
                for (uint8_t i = 0; i<BUFFER_SIZE; i=i+1){
                	MemoryTX[i+tx_count*BUFFER_SIZE] = Buffer[i];
				}
                tx_count = tx_count + 1;
                if (tx_count*BUFFER_SIZE>MEMORY_RX_SIZE){
                	tx_count = 0;
                }
                */
//
//                       printf("Send Packet n %d \r\n",PacketCnt);
//
//                       if( PacketCnt == 0xFFFF)
//                       {
//                           PacketCnt = 0;
//                       }
//                       else
//                       {
//                           PacketCnt ++;
//                       }
//                       //Send Frame
//                       DelayMs( 1 );
//           //           Radio.Send( Buffer, 6 );
//                       if (send_data || send_telemetry){
//                       	txfunction();
//                       }
//                       send_data=false;
//                       send_telemetry=false;
//                       Radio.Send(SEND_DATA, sizeof(SEND_DATA));
//                       State = LOWPOWER;
                       break;

            }
            case TX_TIMEOUT:
            {
                State = LOWPOWER;
                break;
            }
            case LOWPOWER:
            default:
            	defaultCounter = defaultCounter + 1;
                //State = RX;
            	if (reception_ack_mode){
            		State = RX;
            	}
            	else if (telecommand_rx){	//We have received at least one telecommand
            		if (request_execution ){	//In this case we have to TX request or wait for ACK
            			if (request_counter == 3){	//If 3 request have been sent, we send an error message
            				request_execution = false;
            				error_telecommand = true;
            				telecommand_rx = false;
            			}
            			State = RX;
            			/*State = TX;*/// IN THE CASE OF RETRANSMISSIONS OF REQUEST
            			//TimerStart(&CADTimeoutTimer);
            			//Radio.Rx( RX_TIMEOUT_VALUE );
            			//DelayMs(500);
            			//if (!PacketReceived){	//If in 500 ms the RX IRQ does not jump, we go to TX the request or the error
            			//	State = TX;
            			//}
            		} else{	//We want to Rx the second telecommand
            			//TimerStart(&CADTimeoutTimer);
            			//Radio.Rx( RX_TIMEOUT_VALUE );
						//DelayMs(500);
						State = RX; //If Timeout passes and the 2nd telecommand is not received, goes to RX and will process the first, as if the second has been RX
						//PacketReceived = true;
					}
            	}
            	else if (tx_non_stop || error_telecommand || tx_flag){
            		State = TX;
            	}else{
            		State = RX;
            	}

                // Set low power
                break;
        }

        TimerLowPowerHandler( );
        // Process Radio IRQ
        //Radio.IrqProcess( );
    }

}

void txfunction( void ){
	//uint64_t dataVect[sizeof(photo_vect)/8 +1];
	/*uint64_t info[100/8+1];
	uint8_t aux[8];
	uint8_t pos=0;
	Flash_Read_Data(TEST_ADDRESS, &info, sizeof(info));
	for (uint8_t i = 0; i<BUFFER_SIZE; i=i+1){
		//Buffer[i] = Memory[i+txCounter*BUFFER_SIZE];
		memcpy(&aux, info[i], sizeof(aux));
		for(uint8_t j = 0; j<8; j++){
			Buffer[pos+i]=info[i];
		}
		pos= pos+8;
	}
	txCounter = txCounter + 1;
	if (MEMORY_SIZE < ( BUFFER_SIZE*txCounter + BUFFER_SIZE )){
		txCounter = 0;
		tx_non_stop = 0;
	}*/
	uint16_t size = sizeof(photo_vect)/8+1;
//	uint64_t photo[sizeof(photo_vect)/8+1];
	uint8_t photo_8[(sizeof(photo_vect)/8+1)*8];
//	Flash_Read_Data(PHOTO_ADDR , &photo_8, 256);
//	//memcpy(&photo_8, photo, sizeof(photo_8));
	uint16_t read_size = 256;
	uint16_t size_aux = size;
		//for(uint16_t i=0; i<size; i=i+256){
			//Flash_Read_Data(PHOTO_ADDR + (i*8), &photo_8[i*8], read_size);
			//size_aux-=256;
			//if(size_aux<256){
				//read_size=size_aux;
			//}
	//}
	Flash_Read_Data(PHOTO_ADDR + (txCounter*BUFFER_SIZE), &photo_8[txCounter*BUFFER_SIZE], BUFFER_SIZE);
	for (uint8_t i = 0; i<BUFFER_SIZE; i=i+1){
		Buffer[i] = photo_8[i+txCounter*BUFFER_SIZE];
	}
		txCounter = txCounter + 1;
//		if (MEMORY_SIZE < ( txCounter*BUFFER_SIZE + BUFFER_SIZE )){
//			txCounter = 0;
//			tx_non_stop = 0;
//		}
	if(txCounter>=WINDOW_SIZE){
		tx_flag = false;
		tx_non_stop=false;
		State=RX;
	}
}


void OnTxDone( void )
{
    Radio.Standby( );
    if (tx_non_stop == 1){
        State = TX;
    } else{
        State = LOWPOWER;
    }
}

void OnRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )
{
    Radio.Standby( );
    BufferSize = size;
    memcpy( Buffer, payload, BufferSize );
    uint8_t RXactual[BufferSize];
    memcpy( RXactual, payload, BufferSize );
    RssiValue = rssi;
    SnrValue = snr;
    PacketReceived = true;
    RssiMoy = (((RssiMoy * RxCorrectCnt) + RssiValue) / (RxCorrectCnt + 1));
    SnrMoy = (((SnrMoy * RxCorrectCnt) + SnrValue) / (RxCorrectCnt + 1));
    State = RX;
    testRX = 1;
}

void OnTxTimeout( void )
{
    Radio.Standby( );
    State = TX_TIMEOUT;
}

void OnRxTimeout( void )
{
    Radio.Standby( );
    if( RxTimeoutTimerIrqFlag )
    {
        State = RX_TIMEOUT;
    }
    else
    {
        Radio.Rx( RX_TIMEOUT_VALUE );   //  Restart Rx
        SymbTimeoutCnt++;               //  if we pass here because of Symbol Timeout
        State = LOWPOWER;
    }
}

void OnRxError( void )
{
    Radio.Standby( );
    State = RX_ERROR;
}

void OnCadDone( bool channelActivityDetected)
{
    Radio.Standby( );

    if( channelActivityDetected == true )
    {
        CadRx = CAD_SUCCESS;
    }
    else
    {
        CadRx = CAD_FAIL;
    }
    State = RX;
}

void SX126xConfigureCad( RadioLoRaCadSymbols_t cadSymbolNum, uint8_t cadDetPeak, uint8_t cadDetMin , uint32_t cadTimeout)
{
    SX126xSetDioIrqParams( 	IRQ_CAD_DONE | IRQ_CAD_ACTIVITY_DETECTED, IRQ_CAD_DONE | IRQ_CAD_ACTIVITY_DETECTED,
                            IRQ_RADIO_NONE, IRQ_RADIO_NONE );
    //SX126xSetCadParams( cadSymbolNum, cadDetPeak, cadDetMin, LORA_CAD_ONLY, ((cadTimeout * 1000) / 15.625 ));
    SX126xSetCadParams( cadSymbolNum, cadDetPeak, cadDetMin, LORA_CAD_RX, ((cadTimeout * 15.625) / 1000 ));
    //THE TOTAL CAD TIMEOUT CAN BE EQUAL TO RX TIMEOUT (IT SHALL NOT BE HIGHER THAN 4 SECONDS)
}

static void CADTimeoutTimeoutIrq( void )
{
    Radio.Standby( );
    State = LOWPOWER;
    //State = START_CAD;
    //State = RX;
}

static void RxTimeoutTimerIrq( void )
{
    RxTimeoutTimerIrqFlag = true;
}

/**************************************************************************************
 *                                                                                    *
 * 	Function:  pin_correct		                                                      *
 * --------------------                                                               *
 * 	check if the pin in the telecommand is correct								      *
 *                                                                                    *
 *  pin_1: first byte of the pin			                                          *
 *  pin_2: second byte of the pin													  *
 *                                                                                    *
 *  returns: true if correct							                              *
 *                                                                                    *
 **************************************************************************************/
bool pin_correct(uint8_t pin_1, uint8_t pin_2) {
	if (pin_1 == PIN1 && pin_2 == PIN2){
		return true;
	}
	return false;
}


/**************************************************************************************
 *                                                                                    *
 * 	Function:  process_telecommand                                                    *
 * --------------------                                                               *
 * 	processes the information contained in the packet depending on the telecommand    *
 * 	received																	      *
 *                                                                                    *
 *  header: number of telecommand			                                          *
 *  info: information contained in the received packet								  *
 *                                                                                    *
 *  returns: nothing									                              *
 *                                                                                    *
 **************************************************************************************/
void process_telecommand(uint8_t header, uint8_t info) {
	uint64_t info_write;
	uint8_t uno=1;
	switch(header) {
	case RESET2:
		HAL_NVIC_SystemReset();
		break;
	case NOMINAL:
		//info_write = info;
		info_write=Buffer[2];
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1); //NOMINAL
		break;
	case LOW:
		//info_write=info;
		info_write=Buffer[2];
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1); //LOW
		break;
	case CRITICAL:
		info_write=info;
		Flash_Write_Data(TEST_ADDRESS+16, &info_write, 1);  //CRITICAL
		break;
	case EXIT_LOW_POWER:{
		info_write=info;
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1);  //EXIT LOW POWER FLAG

		Flash_Write_Data(TEST_ADDRESS+8, &uno, 1);		//EXIT LOW POWER
		break;
	}
	case EXIT_SURVIVAL:{
		//info_write=info;
		//Flash_Write_Data(EXIT_LOW_POWER_FLAG_ADDR, &info_write, 1);
		Flash_Write_Data(TEST_ADDRESS, &uno, 1); //SURVIVAL
		break;
	}
	case EXIT_SUNSAFE:{
		//Flash_Write_Data(EXIT_LOW_POWER_FLAG_ADDR, &info, 1);
		Flash_Write_Data(TEST_ADDRESS+8, &uno, 1); //SUNSAFE
		break;
	}
	case SET_TIME:{
		uint32_t temps=1653043842;  //example
		uint8_t time[4];
		memcpy(time, &temps, sizeof(temps));
//		for (k=0; k<4; k++){
//			time[k]=Buffer[k+1];
//		}
		Flash_Write_Data(TEST_ADDRESS, &time, 1); //TEMPS_ADDR
		//Flash_Write_Data(TEMP_ADDR, &time, sizeof(time));
		break;
	}
	case SET_CONSTANT_KP:
		info_write=info;
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1); //KP_ADDR
		break;
	case TLE:{
		uint8_t tle[UPLINK_BUFFER_SIZE-1];
		for (k=1; k<UPLINK_BUFFER_SIZE; k++){
			tle[k-1]=Buffer[k];
		}
		Flash_Write_Data(TLE_ADDR + tle_packets*UPLINK_BUFFER_SIZE, &tle, sizeof(tle));
		tle_packets++;
		uint8_t integer_part = (uint8_t) 138/UPLINK_BUFFER_SIZE;
		if (tle_packets == integer_part+1){
			tle_packets = 0;
		}
		//example:
	       	   //0123456789012345678901234567890123456789012345678901234567890123456789

		//1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927
		//2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537

//		uint8_t linia1[69]={'1',' ','2','5','5','4','4', 'U',' ', '9','8', '0','6','7', 'A',' ',' ',' ', '0','8','2','6','4', '.','5', '1','7','8', '2','5', '2','8',' ', '-','.','0','0','0','0','2','1','8','2',' ',' ', '0','0','0','0','0','-','0',' ','-','1','1','6','0','6','-','4',' ', '0',' ',' ', '2','9','2', '7'};
//		info_write=linia1[69];
//		Flash_Write_Data(TEST_ADDRESS_11, &info_write, 4);
//		uint8_t linia2[69]={'2',' ','2','5','5','4','4',' ', ' ','5','1','.','6','4','1','6',' ','2','4','7','.','4','6','2','7',' ','0','0','0','6','7','0','3',' ','1','3','0','.','5','3','6','0','3','2','5','.','0','2','8','8',' ','1','5','.','7','2','1','2','5','3','9','1','5','6','3','5','3', '7'};
//		info_write=linia2[69];
//		Flash_Write_Data(TEST_ADDRESS_12, &info_write,4);
		break;
	}
	case SET_GYRO_RES:
		/*4 possibles estats, rebrem 00/01/10/11*/
		info_write=info;
		//Flash_Write_Data(GYRO_RES_ADDR, &info, 1);
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		break;
	case SEND_DATA:{
		if (!contingency){
			sixfourtoeight();
			tx_flag = true;	//Activates TX flag
			State = TX;
			send_data = true;
		}
		break;
	}
	case SEND_TELEMETRY:{
		/* SEND TELEMETRY DIRECTLY FROM HERE WITH RADIO.SEND */
		if (!contingency){
			send_telemetry = true;
			num_telemetry = (uint8_t) 34/BUFFER_SIZE + 1; //cast to integer to erase the decimal part
			//State = TX;
		}
		break;
	}
	case STOP_SENDING_DATA:{
		send_data = false;
		count_packet[0] = 0;
		break;
	}
	case ACK_DATA:{
		//check it
	 	 ack = ack & Buffer[1];
		 for(j=2; j<ACK_PAYLOAD_LENGTH; j++){
			 ack = (ack << 8*j) & Buffer[j];
		 }
		 count_window[0] = 0;
		 full_window = false;
		 if (ack != 0xFFFFFFFFFFFFFFFF){
			 nack = true;
		 }
		 //State = TX;
		break;
	}
	case SET_SF_CR: {
		uint8_t SF;
		if (info == 0) SF = 7;
		else if (info == 1) SF = 8;
		else if (info == 2) SF = 9;
		else if (info == 3) SF = 10;
		else if (info == 4) SF = 11;
		else if (info == 5) SF = 12;
		//Flash_Write_Data(SF_ADDR, &SF, 1);
		info_write=SF;
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1);
		/*4 cases (4/5, 4/6, 4/7,1/2), so we will receive and store 0, 1, 2 or 3*/
		//Flash_Write_Data(CRC_ADDR, &Buffer[2], 1);
		info_write=2;
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		break;
	}
	case SEND_CALIBRATION:{	//Rx calibration
		/* RX OR SEND???? */
		/* IT TX, IT CAN BE DONE WITH ONE PACKET DIRECTLY FROM HERE RADIO.SEND */
		uint8_t calib[UPLINK_BUFFER_SIZE-1];
		for (k=1; k<UPLINK_BUFFER_SIZE; k++){
			calib[k-1]=Buffer[k];
		}
		Flash_Write_Data(CALIBRATION_ADDR, &calib, sizeof(calib));
		calib_packets = calib_packets + 1;
		uint8_t integer_part = (uint8_t) 138/UPLINK_BUFFER_SIZE;
		if(calib_packets == integer_part+1){
			calib_packets = 0;
		}
		break;
	}
	case TAKE_PHOTO:{
		/*GUARDAR TEMPS FOTO?*/
//		Flash_Write_Data(PAYLOAD_STATE_ADDR, TRUE, 1);
//		Flash_Write_Data(PL_TIME_ADDR, &info, 4);
//		Flash_Write_Data(PHOTO_RESOL_ADDR, &Buffer[5], 1);
//		Flash_Write_Data(PHOTO_COMPRESSION_ADDR, &Buffer[6], 1);
		Flash_Write_Data(TEST_ADDRESS, &uno, 1);
		info_write=info;
		Flash_Write_Data(TEST_ADDRESS+8, &info_write,1);
		info_write=Buffer[5];
		Flash_Write_Data(TEST_ADDRESS,&info_write ,1);
		info_write=Buffer[6];
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		break;
	}
	case TAKE_RF:{
//		Flash_Write_Data(PAYLOAD_STATE_ADDR, TRUE, 1);
//		Flash_Write_Data(PL_TIME_ADDR, &info, 8);
//		Flash_Write_Data(F_MIN_ADDR, &Buffer[9], 1);
//		Flash_Write_Data(F_MAX_ADDR, &Buffer[10], 1);
//		Flash_Write_Data(DELTA_F_ADDR, &Buffer[11], 1);
//		Flash_Write_Data(INTEGRATION_TIME_ADDR, &Buffer[12], 1);
		Flash_Write_Data(TEST_ADDRESS, &uno, 1);
		info_write=info;
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		info_write=9;
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1);
		info_write=10;
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		info_write=11;
		Flash_Write_Data(TEST_ADDRESS, &info_write, 1);
		info_write=12;
		Flash_Write_Data(TEST_ADDRESS+8, &info_write, 1);
		break;
	}
	case SEND_CONFIG:{
		uint8_t config[CONFIG_SIZE];
		Flash_Read_Data(CONFIG_ADDR, &config, CONFIG_SIZE);
		Radio.Send( config, CONFIG_SIZE );
		break;
	}
	default:{
		State = TX;
		error_telecommand = true;
	}
	}
}
//funció per provar process_telecommand
//void telecommands(void){
//
//		uint8_t prova =0;
//		uint8_t info=3;
//		for(prova=11; prova<50 ; prova++){
//			process_telecommand(prova, info);
//			info=info+3;
//		}
//
//}
void eighttosixfour (void){
		uint64_t dataVect[sizeof(photo_vect)/8 +1];
		//uint16_t size = sizeof(photo_vect);
	  		memcpy(&dataVect, photo_vect, sizeof(dataVect));
//	  		uint64_t info_write;
//	  		info_write=dataVect;
	  		Flash_Write_Data(PHOTO_ADDR, &photo_vect, (sizeof(photo_vect)/8 +1));

}
void sixfourtoeight(void){
		uint8_t correct[sizeof(photo_vect)];
		uint64_t dataVect1[sizeof(photo_vect)/8 +1];
  		memcpy(&correct, dataVect1, sizeof(correct));
}
//void read_photo (uint16_t size){
//	uint8_t read_size = 256;
//	for(uint8_t i=0; i<size; i=i+256){
//		Flash_Read_Data(PHOTO_ADDR + i, &photo_8, read_size);
//		size-=256;
//		if(size<256){
//			read_size=size;
//		}
//	}
//}
